# JWT 토큰 인증 방식 설명

## 🔐 JWT 토큰 인증이 필요한 이유

### 현재 구현 방식

1. **로그인 시:**
   - 사용자가 아이디/비밀번호 입력
   - Railway API에서 인증 확인
   - JWT 토큰 발급
   - 쿠키에 토큰 저장 (`httpOnly: true`)

2. **API 호출 시:**
   - 쿠키에서 토큰 읽기
   - `Authorization: Bearer {token}` 헤더로 전송
   - Railway API에서 토큰 검증

---

## ✅ JWT 토큰의 장점

### 1. 보안

**문제: 로그인 정보만 사용하는 경우**
- 매 요청마다 아이디/비밀번호를 전송해야 함
- 네트워크에 비밀번호가 노출될 위험
- 중간자 공격(MITM)에 취약

**해결: JWT 토큰 사용**
- 비밀번호는 로그인 시에만 전송
- 토큰은 만료 시간이 있어 자동으로 무효화
- 토큰이 탈취되어도 만료 시간 후에는 사용 불가

### 2. 성능

**로그인 정보만 사용:**
- 매 요청마다 데이터베이스에서 사용자 인증 확인 필요
- 데이터베이스 부하 증가

**JWT 토큰 사용:**
- 토큰 검증만 하면 되므로 빠름
- 데이터베이스 조회 불필요 (토큰에 정보 포함)

### 3. 확장성

**로그인 정보만 사용:**
- 서버 간 상태 공유 어려움
- 세션 저장소 필요

**JWT 토큰 사용:**
- 서버 간 상태 공유 불필요
- 무상태(Stateless) 아키텍처 지원

---

## 🔄 대안: 세션 기반 인증

JWT 토큰 대신 세션 기반 인증을 사용할 수도 있습니다:

### 세션 기반 인증 방식

1. **로그인 시:**
   - 사용자가 아이디/비밀번호 입력
   - Railway API에서 인증 확인
   - 세션 ID 발급
   - 쿠키에 세션 ID 저장

2. **API 호출 시:**
   - 쿠키에서 세션 ID 읽기
   - Railway API에서 세션 확인
   - 세션 정보로 사용자 인증

### 세션 vs JWT 비교

| 항목 | 세션 | JWT |
|------|------|-----|
| 보안 | 높음 (서버에서 관리) | 높음 (서명 검증) |
| 성능 | 중간 (DB 조회 필요) | 높음 (검증만) |
| 확장성 | 낮음 (세션 저장소 필요) | 높음 (무상태) |
| 구현 복잡도 | 중간 | 낮음 |

---

## 💡 현재 구현 권장 사항

**현재 JWT 토큰 방식 유지 권장:**

1. **이미 구현되어 있음**
   - Railway API에 JWT 검증 로직 구현됨
   - Vercel에서 토큰 관리 구현됨

2. **보안상 안전함**
   - `httpOnly` 쿠키로 XSS 공격 방지
   - 토큰 만료 시간으로 자동 무효화

3. **성능상 유리함**
   - 데이터베이스 조회 불필요
   - 빠른 인증 처리

---

## 🔧 만약 세션 방식으로 변경한다면

### Railway API 변경 필요:

1. **세션 저장소 추가**
   - Redis 또는 데이터베이스 세션 테이블

2. **인증 미들웨어 변경**
   - JWT 검증 → 세션 확인

3. **로그인 엔드포인트 변경**
   - JWT 토큰 발급 → 세션 ID 발급

### Vercel 변경 필요:

1. **쿠키 저장 방식 변경**
   - 토큰 저장 → 세션 ID 저장

2. **API 호출 변경**
   - `Authorization: Bearer {token}` → 세션 쿠키 자동 전송

---

## 📋 결론

**현재 JWT 토큰 방식 유지 권장:**

1. ✅ 이미 구현되어 있음
2. ✅ 보안상 안전함
3. ✅ 성능상 유리함
4. ✅ 확장성 좋음
5. ✅ 표준적인 방식

**세션 방식으로 변경하는 경우:**
- 추가 개발 시간 필요
- 세션 저장소 구축 필요
- 성능 저하 가능성

---

**문서 버전**: 1.0  
**최종 업데이트**: 2026-01-06
